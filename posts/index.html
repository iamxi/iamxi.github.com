<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | 我的博客</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 我的博客">
<meta name="author" content="">
<link rel="canonical" href="https://blog.qiwei.dev/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.qiwei.dev/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.qiwei.dev/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.qiwei.dev/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.qiwei.dev/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.qiwei.dev/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://blog.qiwei.dev/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://blog.qiwei.dev/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.qiwei.dev/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.qiwei.dev/" accesskey="h" title="我的博客 (Alt + H)">我的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.qiwei.dev/posts" title="Blogs">
                    <span class="active">Blogs</span>
                </a>
            </li>
            <li>
                <a href="https://blog.qiwei.dev/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://blog.qiwei.dev/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://blog.qiwei.dev/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Zuul网关丢失鉴权信息问题
    </h2>
  </header>
  <div class="entry-content">
    <p>公司有个项目使用spring cloud全家桶。由zuul做入口，路由到各个业务系统。其中路由完成登陆鉴权。后来有一个业务系统需要用到这些登陆信息，所以希望路由这端将登陆的信息通过消息头的方式带到业务系统。
想想实现很简单，定义一个feign的拦截器，把登陆信息填到header中。不过中间遇到个小问题。统一的路由中将信息保持到了一个ThreadLocal中，拦截器会从这个ThreadLocal中取出数据。问题就出在这里，取到的数据是空的。其他地方也在使用这个ThreadLocal中的数据，并未发现问题，未读这个feign拦截器却不行。最奇怪的本地测试可以，跑测试环境就不行。
再三排查，也查了不少资料，最后看到有博客上提到差不多的问题，原因是Hystrix的策略导致的。Hystrix使用不同的线程完成工作，也就是说Hystrix的线程与Request不再同一个线程中。这样，基于ThreadLocal的一些功能都无法正常使用。后来再stackoverflow上找到了解决办法，连接。框架的开发者也知道这问题，所以提供了一套完整的解决方案。HystrixRequestContext和HystrixRequestVariableDefault就是用来解决这个跨线程时共享数据问题的。简单的说，放入HystrixRequestVariableDefault中的数据，不管是在Requst线程中，还是在Hystrix的线程中，都可以访问到。不过HystrixRequestVariableDefault必须在每一个请求开始的时候进行初始化，同时在请求结束收回收里面的数据。
方案有了，上代码，先实现一个mvc的拦截器，将ThreadLocal中的数据转到HystrixRequestVariableDefault中：
public class HystrixContext { public static final String LOGIN_INFO_HEADER_KEY = &#34;his-login-info&#34;; public static final String TOKEN_HEADER_KEY = &#34;token&#34;; public static final HystrixRequestVariableDefault&lt;LoginInfo&gt; LOGIN_INFO = new HystrixRequestVariableDefault&lt;&gt;(); } try { if (!HystrixRequestContext.isCurrentThreadInitialized()) { HystrixRequestContext.initializeContext(); } LoginInfo loginInfo = convertLoginInf(request.getHeader(HystrixContext.LOGIN_INFO_HEADER_KEY)); LoginInfoUtil.setInfo(loginInfo); String token = request.getHeader(HystrixContext.TOKEN_HEADER_KEY); LoginInfoUtil.setToken(token); HystrixContext.LOGIN_INFO.set(LoginInfoUtil.getLoginInfo()); } catch (Exception e) { LOG.error(&#34;从头信息中获取数据失败&#34;, e); } 然后给feign加一个拦截器：
try { if (!HystrixRequestContext.isCurrentThreadInitialized()) { HystrixRequestContext.initializeContext(); } LoginInfo loginInfo = HystrixContext.LOGIN_INFO.get(); if (loginInfo !...</p>
  </div>
  <footer class="entry-footer"><span title='2019-06-28 15:43:46 +0800 CST'>June 28, 2019</span></footer>
  <a class="entry-link" aria-label="post link to Zuul网关丢失鉴权信息问题" href="https://blog.qiwei.dev/posts/coding/zuul-gateway-lost-auth-info/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Django2 Template 路径配置
    </h2>
  </header>
  <div class="entry-content">
    <p>前端时间在那django些个小网站，其中需要配置下template路径，按以前经验配置了下，
TEMPLATE_DIRS = ( os.path.join(BASE_DIR, &#39;templates&#39;).replace(&#39;\\&#39;, &#39;/&#39;), ) 弄了半天也没成功。最后无奈去看了下官方文档，找到内容有限，不过可以确定的是TEMPLATE_DIRS这个配置项已经没有了。
然后谷歌了下，找到了新的配置方法：
TEMPLATES = [ { &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;, # 这里，这个DIRS就是 &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;).replace(&#39;\\&#39;, &#39;/&#39;),], &#39;APP_DIRS&#39;: True, &#39;OPTIONS&#39;: { &#39;context_processors&#39;: [ &#39;django.template.context_processors.debug&#39;, &#39;django.template.context_processors.request&#39;, &#39;django.contrib.auth.context_processors.auth&#39;, &#39;django.contrib.messages.context_processors.messages&#39;, ], }, }, ] 这个方法在django 1.8以上到我现在的2.0.2有效。不保证以后版本依然有效。</p>
  </div>
  <footer class="entry-footer"><span title='2018-03-22 15:43:46 +0800 CST'>March 22, 2018</span></footer>
  <a class="entry-link" aria-label="post link to Django2 Template 路径配置" href="https://blog.qiwei.dev/posts/coding/django2-template-path-config/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>spring cloud feign 拦截器配置
    </h2>
  </header>
  <div class="entry-content">
    <p>问题 公司大规模推全链路，要求所有应用都接入。手头一个新的项目，采用spring cloud框架。通过 feign 调用rest接口。但是支持提供的支持 HttpClient4 的方式无法对 feign 起作用。
思路 想着 feign 也是采用 HttpClient 的。按理对 HttpClient4 起作用的也应该同样有效。然后去看了下架构组全链路配置代码，原来他们是在初始化 HttpCLient 实例时候，加入了拦截器。通过拦截器，在 header 中加入链路信息。但是这个方式似乎对 feign 没啥作用。那我就自己实现添加拦截器呗。
查了下 feign 添加拦截器，网络上提供的方式都是通过自定义 FeignConfiguration 的方式来实现。方法如下：
新建 FeignConfiguration类
public class FeignConfiguration { @Bean public FeignBasicAuthRequestInterceptor basicAuthRequestInterceptor() { return new FeignBasicAuthRequestInterceptor(); } } 然后在配置客户端调用时候加入配置中
@FeignClient(value = &#34;xxx-service&#34;, path = &#34;/xxx&#34;, configuration = FeignConfiguration.class) 只是这种方法无法做到全局。找了好久，看了文档，都没有办法配置全局。
无奈，去翻源码吧。找到了 FeignAutoConfiguration 类。看到了初始化配置。
protected static class HttpClientFeignConfiguration { @Autowired( required = false ) private HttpClient httpClient; protected HttpClientFeignConfiguration() { } @Bean @ConditionalOnMissingBean({Client....</p>
  </div>
  <footer class="entry-footer"><span title='2018-01-25 20:53:21 +0800 CST'>January 25, 2018</span></footer>
  <a class="entry-link" aria-label="post link to spring cloud feign 拦截器配置" href="https://blog.qiwei.dev/posts/coding/spring-cloud-feign-add-interceptor/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>javabean字段文字拼接
    </h2>
  </header>
  <div class="entry-content">
    <p>问题 接了一个需求，从数据库拿出患者的记录，这些记录都是一些吸烟年份、饮酒年份、是否糖尿病等，不是数字就是布尔值，需要通过代码转化为普通人能理解的文字。
思前想后，总不能使用大量 if-else 判断来拼接字符串吧。可以采用模板，但是那样除了必要判空，代码和模板也将分离，不方便维护。而且有些字段存在依赖关系。
解决 刚好之前看了使用注解来替代枚举的方式。想着是否可以在每个需要拼接的字段上打上注解，通过判断注解的方式拼接。注解中也可以放入模板、依赖关系等配置。
@Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface StringAssemble { /** * 模板 */ String template(); /** * 分类 */ String type() default &#34;&#34;; /** * 上级依赖 */ String dependency() default &#34;&#34;; /** * 相互依赖的内容之间的分割符号 */ String dependencySplit() default &#34;,&#34;; } 上面注解中，templete 主要是字段值需要填入的文字模板，type 用于不同的字段组合，dependency 主要是有依赖关系的字段之间的内容组合，最后一个是有依赖关系的字段字段拼接后用于隔离的标点。
实现代码如下：
private static String stringAssemble(Object data, String type, String splitPunctuation) { final Map&lt;String, String&gt; infoMap = new HashMap&lt;&gt;(); final Map&lt;String, String&gt; dependencyMap = new HashMap&lt;&gt;(); try { Field[] fields = data....</p>
  </div>
  <footer class="entry-footer"><span title='2018-01-20 10:58:21 +0800 CST'>January 20, 2018</span></footer>
  <a class="entry-link" aria-label="post link to javabean字段文字拼接" href="https://blog.qiwei.dev/posts/coding/java-bean-field-assemble/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Dubbo统一异常拦截
    </h2>
  </header>
  <div class="entry-content">
    <p>问题 最近换了岗位，工作内容改成跟着架构师完善公司的技术架构。第一个任务就是做一个统一的异常拦截并返回相关错误码的方案。
公司采用dubbo做分布式框架，按dubbo的推荐，异常已经直接抛给调用方（consumer），只是公司现有的约定是使用错误码。问了几个前辈后才知道，原来dubbo在处理自定义异常的时候有些限制。
public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException { try { Result result = invoker.invoke(invocation); if (result.hasException() &amp;&amp; GenericService.class != invoker.getInterface()) { try { Throwable exception = result.getException(); // 如果是checked异常，直接抛出 if (! (exception instanceof RuntimeException) &amp;&amp; (exception instanceof Exception)) { return result; } // 在方法签名上有声明，直接抛出 try { Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes()); Class&lt;?&gt;[] exceptionClassses = method.getExceptionTypes(); for (Class&lt;?&gt; exceptionClass : exceptionClassses) { if (exception.getClass().equals(exceptionClass)) { return result; } } } catch (NoSuchMethodException e) { return result; } // 未在方法签名上定义的异常，在服务器端打印ERROR日志 logger....</p>
  </div>
  <footer class="entry-footer"><span title='2017-10-09 10:02:55 +0800 CST'>October 9, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Dubbo统一异常拦截" href="https://blog.qiwei.dev/posts/coding/dubbo-exception-filter/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>hexo3搭建博客
    </h2>
  </header>
  <div class="entry-content">
    <p>前几天心血来潮，翻出了不知道那年的博客，用户hexo重新搭建了下。把这个是记录下来。
安装 这个不多说，hexo 官方文档有介绍。
配置 基本的一些配置上面，上面也有，还有一些我参考了这篇博客，在此先谢过这位朋友的分享。
遇到的问题及解决 CNAME 文件 因为 Github 需要 CNAME 文件，用于指定域名。不过放在 public 文件夹中的话，只要 clean 一次就没了。网站找了下资料，应该将其放在 source 目录总，这样在生成时候就会一起带到 public 文件夹中。一些博文中需要的图片（images）和favicon.ico等不变的内容也可以一起放在 source 目录下。
README.md文件不渲染 在站点配置文件中添加
skip_render: README.md stiemap 的生成 需要安装插件
npm install hexo-generator-sitemap --save 站点配置文件中添加配置
sitemap: path: sitemap.xml 博文永久连接 默认是时间分开。但是这样路径比较长。不方便管理。网上有种方法是urlname。使用urlname来作为链接，避免使用文件名。这样文件名就可以自己定义，方便本地管理。
具体做法是，在站点配置文件中，修改配置如下：
permalink: post/:urlname.html 然后在每一篇 post 中都需要加一个urlname，如这篇文章的：
title: 20171001-hexo3搭建博客 date: 2017-10-01 03:44:13 tags: hexo urlname: blog-with-hexo3 缺点是，如果那篇忘记了这个，那生成的 html 文件将会是未知
图片保存 hexo官网有推荐的方法，文档。当时我的觉这个太依赖hexo，不符合markdown的理念。所以，还是选择土办法管理图片，放在 source/images 目录下，post中直接用相对路径应用。亲测可行。
博客的版本控制 hexo 的部署功能，只能建 public 文件夹中的内容推送到 Github 上。而配置文件和博客源文件都无法提交。如果换了电脑或电脑换了，那就什么都要从新开始了。...</p>
  </div>
  <footer class="entry-footer"><span title='2017-10-01 03:44:13 +0800 CST'>October 1, 2017</span></footer>
  <a class="entry-link" aria-label="post link to hexo3搭建博客" href="https://blog.qiwei.dev/posts/other/blog-with-hexo3/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>SpringMVC没有拦截根路径的问题
    </h2>
  </header>
  <div class="entry-content">
    <p>在开发tomcat &#43; spring mvc的web工程时候，发现在controller中配置的根路劲不会被拦截到，或者说前段返回的根本就不是controller中所配置的。比如，我在controller中配置根路径的返回为一个欢迎页面：
@RequestMapping(value = &#34;/&#34;, method = RequestMethod.GET) public ModelAndView main() { ModelAndView mv = new ModelAndView(&#34;main&#34;); return mv; } 但访问“http://localhost:8080/project_name/”，返回的却是404.
在对该单元测试中，对根路径的访问等得到了正确的结果，这证明spring的配置是正确的。于是乎想起来web.xml中的配置可能存在为题，自然最有可能有问题的是web.xml对默认页面的设置了。及welcome-file-list。但是自己并没有配置这个。后来看了tomcat官网对tomcat目录下conf/web.xml的说明才知道，原来此处的web.xml中的配置将被当作默认配置，而部署的工程内的web.xml中的配置会覆盖默认配置，但是如果向我那样没有配置welcome-file-list，那么就会使用默认的了。为此当访问根目录的时候，tomcat试图去寻找默认的index.html等资源，而不是把请求交给spring的拦截器。
知道了这些，解决问的就简单了，直接修改工程下的web.xml，加入如下配置：
&lt;welcome-file-list&gt; &lt;welcome-file&gt;&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 这样就配置后，tomcat就知道不需要对根路径的访问做处理了，而将请求交给了spring的拦截器。</p>
  </div>
  <footer class="entry-footer"><span title='2014-12-02 15:22:00 +0800 CST'>December 2, 2014</span></footer>
  <a class="entry-link" aria-label="post link to SpringMVC没有拦截根路径的问题" href="https://blog.qiwei.dev/posts/coding/springmvc-cant-fiter-root-url/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Spring4定时任务的注解配置
    </h2>
  </header>
  <div class="entry-content">
    <p>不想写繁琐的xml文件，所以试着用Spring的注解来配置定时任务。按网上好多写的那样，使用@Scheduled注解：
@Scheduled(fixedRate=5000) public void doSomething() { // something that should execute periodically } 但是怎么也无法让定时任务跑起来。最后无奈，只有去官网看英语了。
原来，还需要有一个允许定时任务的注解，放在一个有@configuration注解类中。
@Configuration @EnableAsync @EnableScheduling public class AppConfig { } 其中，@EnableAsysnc是允许异步任务。至于@Configuration的说明，见Spring的最新文档。</p>
  </div>
  <footer class="entry-footer"><span title='2014-11-03 22:57:00 +0800 CST'>November 3, 2014</span></footer>
  <a class="entry-link" aria-label="post link to Spring4定时任务的注解配置" href="https://blog.qiwei.dev/posts/coding/spring-scheduling-annotation-support/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>webpy源码阅读之HelloWorld
    </h2>
  </header>
  <div class="entry-content">
    <p>使用过Django和web.py，只是一直没有好好深入学习过，Django使用时间比较长，不过Django庞大了点，不适合我这种没耐心的人去学习，所以选择了web.py。
Hello World! 先看下web.py官方cookbook的“Hello World!”例子
import web urls = (&#34;/.*&#34;), &#34;hello&#34;) app = web.application(urls, globals()) class hello: def GET(self): return &#39;Hello, world!&#39; if __name__ == &#34;__main__&#34;: app.run() 在例子中可以看到app.run()是启动了服务，而app的是application的一个实例，初始化工作是web.application(urls, globals())，就拿这个做入口，来看下application类的源码吧。
初始化 初始化的流程：
初始化mapping 把_load和_unload变成钩子加入到processors 把Reloader和reload_mapping变成钩子加入到processors 载入main所在模块 init的参数有三个，第一个mapping，上面例子中的urls；第二个fvars，例子中的globals()，globals()是python自带的一个函数，其返回值是全局名字空间，包括了函数、类、导入模块等等，是一个字典类型；第三个autoreload，是否允许自动重新载入。
mapping初始化 self.init_mapping(mapping) def init_mapping(self, mapping): self.mapping = list(utils.group(mapping, 2)) 最后mapping的形式会是[[‘1’,‘2’],[‘1’,‘2’]]这样，这边就可以理解urls列表的样式了。
_load和_unload变成钩子加入到processors 关于钩子和处理器详见官网。
self.add_processor(loadhook(self._load)) self.add_processor(unloadhook(self._unload)) loadhook函数的作用就是在执行其参数传入的函数前执行一些操作，unloadhook则是在其后执行一些操作。这两个都类似于python的decorator。而_load和_unload则是将application实例本身加入web.ctx.app_stack或从其中移除。
如果autoreload不为True则初始化就到此为止了。在初始化的时候，如果autoreload为None，则回去参数读取web.config内的debug的值，默认为False，所以如果autoreload参数没有传入，一般都是不会自动加载，后面操作不会再去进行了。
Reloader和reload_mapping变成钩子加入到processors 和第二步相似，reload_mapping就是用来从新载入主的app，并初始化mapping。而Reloader则是在检查磁盘上任何模块是否有变化，如果有则重新加载。
重新import 通过main获取主app所在的模块名称和所在文件名，然后通过文件名重新import。这步还是简单的，不过代码值得一看，可以学好如sys.modules、getattr()及__import__()的用法。
启动服务 def run(self, *middleware): return wsgi.runwsgi(self.wsgifunc(*middleware)) run函数调用wsgi模块的runwsgi函数，在hello world中就是启动一个http simple服务。具体内容等看到wsgi模块和httpserver模块再说了。</p>
  </div>
  <footer class="entry-footer"><span title='2014-04-03 11:21:00 +0800 CST'>April 3, 2014</span></footer>
  <a class="entry-link" aria-label="post link to webpy源码阅读之HelloWorld" href="https://blog.qiwei.dev/posts/coding/webpy-source-helloworld/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>推荐程序员阅读的书籍 -- 编程实践
    </h2>
  </header>
  <div class="entry-content">
    <p>忘记是哪里看到的这份书单了，那时就用思维导图记录了下来，以后相继看了编程实践下的几本书，感觉作者推荐和分类的相当好。编程实践的下书我没有全部阅读过，每个阶段阅读了那么一两本书，在这里简单介绍下那些我阅读过的书。
《编写可读代码的艺术》 这是一本适合刚开始自己的编程生涯的人阅读的书，书的中心内容就是教我们编写出可读性高、整洁、优美的代码，提高代码质量，并把编写更容易理解的代码变成一种习惯。当然，也不是说有经验的程序员就不用看这本书了。我阅读这本书的时候已经不是新手了，不过依然可以从书中学到很多。对于有经验的程序员，很容易忽视一些问题，也更容易养成一些恶习。
《测试驱动开发》 一本很薄的书，如果没有其他干扰，集中注意力的话，一天读完不是问题。书中介绍的形式很特别，作者让我们跟随他，一步一步的去进行测试优先的开发，之后作者还为我们展示了如何使用测试优先的方法一步一步的开发一个类似JUnit的Python单元测试框架。不懂Python语言也没问题，里面的代码很简单，看完后自己的Python入门了。本书还有一个重点，就是作者的任务列表，我现在也在使用这种方法，能在任务中断后继续时帮我快速了解之前所完成的以及接下来需要做的，不至于还要花时间去思考之前做了什么。
《代码大全》 这本书的厚度完全可以和大全两个字联想起来，内容丰富，质量也高，可问题是要看完这么厚的一本书确实难了的。不过还好，作者给出了每个章节适合的人群，根据自己的情况和需要，可以选择性阅读，如果时间多，读读这本也是个好选择。
《程序员修炼之道》 强烈推荐的好书，主要是本人从这本书中受益匪浅。这本书的英文名意思是高效的程序员，所以全书都在讲如何提高自己的效率，从各种习惯到工具再到团队合作，方方面面提高自己的效率。如书的副标题–从小工到专家，等你看完这书，按照书中的方法去实践时，专家可能还远，但是绝对不会再是菜鸟。不管是学生还是富有经验的发开人员都可以去阅读，就算读过一遍，再去随手翻翻也能带来一些感悟。
《计算机程序的构造和解释》 上述的书都是在讲述如何成为好程序员，如何写出好的代码，如何提高自己效率，但这本书就是教我们理解计算机语言和程序本身。这本书曾经是MIT的入门级教材，所以更偏重理论。也许我们学习了不止一门计算机语言，也许我们被那些不同语言的不同特性吸引着或是困恼着，也许我们还只是浅浅的理解了编译器、解析器之类的概念，那么这本书完全可以帮我们换个角度看到编程和语言。它会让我们学到函数式编程、虚拟机、解析器、编译器等等，如果觉得这些太高深了，那么它同样也在讲解语言的组成、基本表达式以及其组合、抽象等等。这本书很适合有一定编程经验的人阅读，可以结合自己的经验学习书中的知识。当然新手也完全可以学习，最大的好处是建立了一套知识体系，对以后学习编程语言和相关内容时候变得更简单高效。不过话说后面，这本书不好消化，看起来费时费脑力。
未提到的书籍 这些书都是具有代表意义的，还有许多经典的书籍值得程序员去阅读。
《编译原理》 （龙书）这类书籍太过高深了，除非向编程语言更深入的发展或是工作领域需要，否则没必要去阅读。
《编程珠玑》 个人感觉值得一读，书中好多都在提如很灵机一动的想出一个好的算法，里面的算法很值得学习，我也在实践中使用过一些。
《算法导论》 里面的算法的确不是一个普通程序员很好理解的，阅读这本书需要高等数据知识，我读了第一章递归求时间复杂度后就放弃了这本书。
《编码：隐匿在计算机软硬件背后的语言》 这本书从小学生之间使用手电筒光来聊天开始，讲到了继电器，使用继电器实现数学逻辑中的各种门，然后利用这些做一个继电器实现的加减法电路，然后…这本书可以让我们明白计算机工作原理，即使没了计算机，我们也可以自己做一台可编程的机械出来。我觉得给我儿子当计算机入门教材不错。
最后说的是自己的提升还是靠自己的努力，书籍只是起引导作用。而且并不是这么多书都要去看，找适合自己的。</p>
  </div>
  <footer class="entry-footer"><span title='2014-02-28 16:48:00 +0800 CST'>February 28, 2014</span></footer>
  <a class="entry-link" aria-label="post link to 推荐程序员阅读的书籍 -- 编程实践" href="https://blog.qiwei.dev/posts/other/developer-read-books-coding/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://blog.qiwei.dev/posts/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://blog.qiwei.dev/">我的博客</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
