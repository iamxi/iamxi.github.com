<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | 我的博客</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 我的博客">
<meta name="author" content="">
<link rel="canonical" href="https://blog.qiwei.dev/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.qiwei.dev/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.qiwei.dev/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.qiwei.dev/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.qiwei.dev/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.qiwei.dev/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://blog.qiwei.dev/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://blog.qiwei.dev/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.qiwei.dev/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.qiwei.dev/" accesskey="h" title="我的博客 (Alt + H)">我的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.qiwei.dev/posts" title="Blogs">
                    <span class="active">Blogs</span>
                </a>
            </li>
            <li>
                <a href="https://blog.qiwei.dev/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://blog.qiwei.dev/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://blog.qiwei.dev/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Java源码解读——ArrayList
    </h2>
  </header>
  <div class="entry-content">
    <p>为了提高自己的Java开发能力，我也向高手、牛人学习，去解读源码。自己底子差了点，不过看个源码还是没问题的。第一站ArrayList。
源码为Java 1.7的源码
ArrayList是一个实现可变长数组，继承AbstractList类，实现所有的List接口，还实现了RandomAccess、Cloneable、Serializable接口。ArrayList不进行同步，除此之外基本和Vector等同。
1、成员变量 private transient Object[] elementData; elementData用于保存数据的数组。
private int size; size为ArrayList内的数据数量，但并不是elementData的长度。
2、构造方法 public ArrayList(int initialCapacity) { super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&#34;Illegal Capacity: &#34;&#43; initialCapacity); this.elementData = new Object[initialCapacity]; } public ArrayList() { this(10); } public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } 第一个是根据指定长度建立List，第二个是根据默认长度建立List，第三个根据传入Collection子类实例创建List。通过第三个实例看到Collection子类都会实现toArray()方法，可以看出至少很多Collection子类依赖于数组来实现（还没看过其他的集合实现，这只是我的妄言而已）。
3、add方法 public boolean add(E e) { ensureCapacityInternal(size &#43; 1); elementData[size&#43;&#43;] = e; return true; } 该方法在数组最后添加一个元素。ensureCapacityInternal方法提供了ArrayList的自增长实现，以确保elementData有足够的长度来容纳新进入的元素（后面介绍自增长的实现）。...</p>
  </div>
  <footer class="entry-footer"><span title='2013-08-14 15:11:00 +0800 CST'>August 14, 2013</span></footer>
  <a class="entry-link" aria-label="post link to Java源码解读——ArrayList" href="https://blog.qiwei.dev/posts/coding/java-source-arraylist/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>编写可读代码的艺术-代码应当易于理解
    </h2>
  </header>
  <div class="entry-content">
    <p>虽说我编程也有五年了，不过很多细节的东西还是不够注意。关于别人是否能读懂自己所写的代码，这个问题的确很少在平常的开发中想过，即使有过这个念头，最多的也就是考虑下代码的结构清晰，这有助于减少BUG，方便阅读。至于其他相关的就比较少解除了，或是完全没有概念。之前学习过变量和函数的命名，不过实际中很少考虑，命名很是随意。读这书是希望提高下自己的代码质量，当然个人认为代码的可读、整洁、优美是代码质量的一部分。
可读性基本定理 定理：代码的写法应当是别人理解它所需的时间最小化
找一个同事，测试下他读自己代码并理解它所需要的时间，这个“理解代码时间”就是最小化的理论度量。并且这个“理解”有很高的标准，真的完全理解所看的代码的话，就能改动它、找出缺陷并明白它是如何与代码的其他部分交互的。
总是越小越好吗 从代码数量上来看，越少的代码，阅读和理解的速度就应该越快，但这不是必然，少的代码并不总是更好，如：
assert((!(bucket = FindBucket(key))) || !bucket-&gt;IsOccupied()); 相比
bucket = FindBucket(key); if (bucket != NULL) assert(!bucket-&gt;IsOccupied()); 前者理解起来比后者两行代码所花的时间更多。
有时候一条适合的注释可以让阅读着更快地理解代码，尽管增加了长度。
理解代码所需的时间是否与其他目标有冲突 这里说的其他目标包括优化、架构、测试等。不过答案是否定的，这些根本不会相互影响。更多的介绍会在后面章节提到。
最难的部分 是的，最难的部分是让养成一个在编码时考虑如何让他人更容易理解你的代码的习惯。这不光需要时间去适应，而且需要一定的毅力。开发过程中各种情况都会让你放弃这种想法，比如进度、他人代码的质量等。
如果你是个新手，说真的，这书值得去看。在日常的工作中，去理解他人代码或是他人来阅读你的代码的情景时常有。甚至自己也会忘记自己所写代码的含义，一周或一个月后再去看自己的代码，都觉得那么陌生。项目的维护时间远多余开发，当后期需要再次开发或修改BUG的时候，那些好的、易于理解的代码将大大节省时间。所以编写可读代码不经方便他人，还能提高自身的工作效率。</p>
  </div>
  <footer class="entry-footer"><span title='2013-08-09 17:12:00 +0800 CST'>August 9, 2013</span></footer>
  <a class="entry-link" aria-label="post link to 编写可读代码的艺术-代码应当易于理解" href="https://blog.qiwei.dev/posts/coding/the-art-of-readable-code/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>霸王别姬-人生一场戏
    </h2>
  </header>
  <div class="entry-content">
    <p>中午闲着没事看了下陈凯歌导言的《霸王别姬》，先不说其他的，吐槽下英文名——《Farewell My Concubine》，意思是“告别我的情妇”，让我怎么和“霸王别姬”这四个字联系起来。怪不得中国的文学作品老拿不到国际的什么奖。
程蝶衣 幼年的他是不是找女娃来演的啊，那个秀气啊。幼年的他一脸漠然像，感觉他对自己人生没有任何的想法，听天由命。当他逃出戏班子，在剧院看了那出霸王别姬后，似乎他才确认了他人生的目标。
他的人生就是一段戏，入戏的时候实在他说出“我本是女娇娥，又不是男儿郎”，出戏是在电影最后，说出了“我本是男儿郎，又不是女娇娥”。期间他就一直沉浸在他自己的戏里面。按段小楼的说法是他简直是入魔了。幼年的蝶衣柔弱、胆小，而后来的他却显得坚毅、勇敢，特别是找日本人救小楼。再加上对小楼的那份情，这不正是霸王别姬中虞姬应有的吗。应了袁四爷那句话“虞姬是真虞姬”。
蝶衣最后选择了自杀，在他说出了“我本是男儿郎，又不是女娇娥”后。相信在他说出这句话后他已经出戏了，而这场戏，一演就是大半辈子。回首往事，再看已经不存在了的霸王，以及将来要承受的现实，像虞姬那样自刎是他唯一的选择了，他的自刎也为他如戏的一生画上了圆满的句号。
电影中蝶衣对他母亲的感情描述的地方很少，我记得只有三处：烧掉他母亲给的衣服；写信给母亲然后烧掉；在戒毒的时候喊着娘。他心里对他母亲是又爱又恨，烧掉他母亲给他的衣服，这是因为他母亲风尘女子的身份，是他无法抬头面对他人。而烧掉给他母亲的信，他完全就当母亲已经不在人世了，电影没有介绍他去寻找他母亲，或是根本就没打算寻找，也许是还恨着母亲抛弃他吧。而写信说明还是思念母亲。在他最艰难时刻含着“娘”，那些对话是在他小时候对他母亲说的，他还依然保留这小时候和母亲在一起的记忆。这里也说明了蝶衣记忆力为什么这么好了，他怕失去，所以一直记着。在开始的时候蝶衣能清楚的说出不唱戏的时间和两人没见面的时间。
段小楼 电影开始那个说话没底气的人很难与后面那个脾气差、耿直、冲动的段小楼对着上，直到看完电影，看着他的一点的一点的改变，才能理解。
不管他是真霸王还是假霸王，按他幼年和出名那会的性格，他的英雄救美，他对日本人的无视，还真与楚霸王几分相似。也许这也是蝶衣一直把他当心中的楚霸王的原因之一吧。
他的人生从菊仙的出现才发生了改变。一个女人能成就一方霸主，也能毁掉一个英雄啊！小楼没有发现蝶衣对他的爱，因为他不知道蝶衣一直在戏里，或是他一直就没入戏，也真实袁四爷那句“虞姬是真虞姬，霸王是假霸王”，不是他演的不够好，而是他本来就没有入戏。所以说菊仙并不是什么第三者，也不能去怪蝶衣的恋情的畸形。身为虞姬的蝶衣自然爱着那个英雄楚霸王，而作为男人的小楼和菊仙在一起也是情理所在。
他的改变也那一代人的改变，从年轻气盛的小伙子，直到成为一个世俗的老人，经历了抗日战争、解放、文革的人，能不改变吗。菊仙对多只算催化剂，不管如何，最后他还是变成那样子的。
菊仙 一个风尘女子，有勇有谋，善于判断形势，也是她加速了小楼的改变。也是他为蝶衣和小楼间带来了冲突。不过她只是一个代表，即使没有菊仙，也会有其他人替补上她的位置，小楼是个男人，终究会结婚生子，他和蝶衣之间的问题总是会出现的。有了菊仙这样的女子，让故事变的更不一般。
菊仙一直担心小楼和蝶衣在一起会出事，反对小楼和蝶衣一起唱戏，她内心的不安出自当初她对誓言的背弃。当她求蝶衣救小楼的时候承诺今后离开小楼，结果她食言了。再加上她为自己赎身时候老鸨说的那番话，也许就能明白她最后自杀的原因了。当小楼说出和她划清界限后，小楼是无奈的，但是在菊仙心里，她会觉得小楼还是介意了她以前的身份。
只是不明白菊仙最后为什么救那把剑。这把剑本来是类似小楼和蝶衣间的定情信物，对于她来说，没有多少价值。
最后 这里面没有三角恋，一个在戏里，一个在戏外；一个在古代，一个在现实。蝶衣对小楼也只是虞姬对霸王的感情，而小楼和菊仙是一对平凡夫妻的感情。
这里面也有因果报应，菊仙、张公公、袁四爷、小四，他们都得到应有的报应。话说蝶衣和小楼估计都把小四当自己的孩子一样看待吧。可惜了这娃，只能说是那个时代的错。
我喜欢戏班子师傅教导徒弟那几话：第一句，人得自各儿成全自各儿。第二句，自古人生一世，需有一技之长，我辈既务斯业，便当专心用功，以后名扬四海，根据全在年轻。是啊，我的一技之长是什么——编程。只能专心用功，以后希望名扬四海。</p>
  </div>
  <footer class="entry-footer"><span title='2013-08-09 12:39:00 +0800 CST'>August 9, 2013</span></footer>
  <a class="entry-link" aria-label="post link to 霸王别姬-人生一场戏" href="https://blog.qiwei.dev/posts/other/farewell-my-concubine/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>设计模式学习-组合模式（Composite）
    </h2>
  </header>
  <div class="entry-content">
    <p>意图： 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。
结构： 参与者
Component(Graphic) 为组合中的对象声明接口。 在适当的情况下，实现所有类共有接口的缺省行为。 (可选)在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它。 Leaf(Rectangle、Line、Text等) 在组合中表示叶节点对象，叶节点没有子节点。 在组合中定义图元对象的行为。 Composite(Picture) 定义有子部件的那些部件的行为。 存储子部件。 在Component接口中实现与子部件有关的操作。 Client 通过Component接口操纵组合部件的对象。 代码示例： Component
public interface Component { public void operation(); public void add(Component item); void remove(Component item); public Component getChild(int i); } Composite
public class Composite implements Component { private List&lt;Component&gt; children = new ArrayList&lt;Component&gt;(); @Override public void operation() { for (Component child : children) { child.operation(); } } @Override public void add(Component item) { this....</p>
  </div>
  <footer class="entry-footer"><span title='2013-08-08 15:27:00 +0800 CST'>August 8, 2013</span></footer>
  <a class="entry-link" aria-label="post link to 设计模式学习-组合模式（Composite）" href="https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-composite/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>原型工厂模式
    </h2>
  </header>
  <div class="entry-content">
    <p>顾名思义就是原型模式和工厂模式的结合。在GOF的书里面，抽象工厂那节中对这个有描述，不过内容很少，所以看的时候也没注意到。
说个实际的问题：系统需要向用户发送短信，但是根据场景的不同，发送的短信格式也不同，比如重置密码和发送临时验证码的短信格式就有区别，而之前的开发人员使用了策略模式，每个内容都有一个类，现在也不方便去改动这些。但是随需求的增加，发送的场景在不断增加，策略&#43;工厂方法模式的情况下需要去增加更多的if-else，导致扩展困难，也使得调用时候不直观。
本人自认为自己小脑瓜没有能力想出好办法，只好去翻下书籍，无意中看到了抽象工厂内介绍原型工厂的内容，想着可以借鉴。如果依靠一定规范的传入参数，通过if-else来判断需要使用的算法闲代码忒长，那么不为什么不直接传入算法呢。当然传入算法的类的话太费资源，但是传个Class或Class Name不适问题。
参数就是用枚举，这比String参数好，原因是String可以传入任何字符串，而枚举只能是枚举内的指定值，枚举代码如下：
public enum MessageBuilderEnum { RESET_PASSWORD_SMS(ResetPwSmsMsgSendServiceImpl.class), RESET_PASSWORD_EMAIL(ResetPwMailMsgSendServiceImpl.class), SMS_FEE(SmsFeeMsgSendServiceImpl.class), TEMP_CODE_SMS(TempCodeSmsMsgSendServiceImpl.class), UNIVERSAL_SMS(BoundMsgSendServiceImpl.class); private Class&lt;?&gt; builderClass; MessageBuilderEnum(Class&lt;?&gt; builderClass) { this.builderClass = builderClass; } public Class&lt;?&gt; getBuidlerClass() { return builderClass; } } 再看下功能实现的代码
private static ConcurrentHashMap&lt;String, AbstractMsgSendServiceImpl&gt; messageBuilder = new ConcurrentHashMap&lt;String, AbstractMsgSendServiceImpl&gt;(); public MessageSendServiceImpl() { for (MessageBuilderEnum builderClass : MessageBuilderEnum.values()) { try { messageBuilder.put(builderClass.getBuidlerClass() .getSimpleName(), (AbstractMsgSendServiceImpl) builderClass .getBuidlerClass().newInstance()); } catch (InstantiationException e) { logger.error(e.getMessage(), e); } catch (IllegalAccessException e) { logger....</p>
  </div>
  <footer class="entry-footer"><span title='2013-07-31 13:58:00 +0800 CST'>July 31, 2013</span></footer>
  <a class="entry-link" aria-label="post link to 原型工厂模式" href="https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-prototype-factory/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>设计模式学习-桥接模式（Bridge）
    </h2>
  </header>
  <div class="entry-content">
    <p>意图 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
别名 Handle/Body
结构 参与者
Abstraction
— 定义抽象类的接口。
— 维护一个指向Implementor类型对象的指针。 RefinedAbstraction
— 扩充由Abstraction定义的接口。 Implementor
— 定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。一般来讲，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。 ConcreteImplementor
— 实现Implementor接口并定义它的具体实现。 示例代码： public abstract class Abstraction { private Implementor impl; public Implementor getImpl() { return impl; } public void setImpl(Implementor impl) { this.impl = impl; } public Abstraction(Implementor impl) { this.impl = impl; } public abstract void operation(); } public class RefinedAbstraction extends Abstraction { public RefinedAbstraction(Implementor impl) { super(impl); } @Override public void operation() { getImpl()....</p>
  </div>
  <footer class="entry-footer"><span title='2013-07-31 13:44:00 +0800 CST'>July 31, 2013</span></footer>
  <a class="entry-link" aria-label="post link to 设计模式学习-桥接模式（Bridge）" href="https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-bridge/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>设计模式学习-适配器（Adapter）
    </h2>
  </header>
  <div class="entry-content">
    <p>如果你知道电源适配器的作用，就应该很容易理解这个模式。
意图： 将一个类的接口转换成客户希望的另外一个接口。 Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
别名： 包装器 Wrapper
结构： 类适配器
对象适配器
适用： 以下情况使用Adapter模式
你想使用一个已经存在的类，而它的接口不符合你的需求。 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。 （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 双向适配器： 一般适配器对使用target接口的透明，无法给使用adaptee接口的使用。双向适配器可以解决这个问题，使适配器更透明。
相关模式： 模式Bridge的结构与对象适配器类似，但是Bridge模式的出发点不同：Bridge目的是将接口部分和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。而Adapter则意味着改变一个已有对象的接口。
Decorator模式增强了其他对象的功能而同时又不改变它的接口。因此Decorator对应用程序的透明性比适配器要好。结果是Decorator支持递归组合，而纯粹使用适配器是不可能实现这一点的。
模式Proxy在不改变它的接口的条件下，为另一个对象定义了一个代理。</p>
  </div>
  <footer class="entry-footer"><span title='2013-07-31 12:26:00 +0800 CST'>July 31, 2013</span></footer>
  <a class="entry-link" aria-label="post link to 设计模式学习-适配器（Adapter）" href="https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-adapter/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>设计模式学习-创建型模式
    </h2>
  </header>
  <div class="entry-content">
    <p>用于创建对象的模式。包括单件模式（Singleton）、抽象工厂模式（Abstract Factory）、生成器模式（Builder）、工厂方法模式（Factory Method）、原型模式（Prototype）。
用一个系统创建的那些对象的类对系统进行参数化有两种常用方法：
一、生成创建对象的类的子类；这对应于使用 Factory Method模式。这种方法的主要缺点是，仅为了改变产品类，就可能需要创建一个新的子类。这样的改变可能是级联的。
二、对系统进行参数化的方法更多的依赖于对象复合：定义一个对象负责明确产品对象的类，并将它作为该系统的参数。这是 Abstract Factory、Builder和Prototype模式的关键特征。所有这三个模式都涉及到创建一个新的负责创建产品对象的“工厂对象”。Abstract Factory由这个工厂对象产生多个类的对象。 Builder由这个工厂对象使用一个相对复杂的协议，逐步创建一个复杂产品。 Prototype由该工厂对象通过拷贝原型对象来创建产品对象。
如何选择： 使用Abstract Factory、Prototype或Builder的设计甚至比使用Factory Method的那些设计更灵活，但它们也更加复杂。通常，设计以使用 Factory Method开始，并且当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。
当然没必要就不要用。</p>
  </div>
  <footer class="entry-footer"><span title='2013-07-31 09:59:00 +0800 CST'>July 31, 2013</span></footer>
  <a class="entry-link" aria-label="post link to 设计模式学习-创建型模式" href="https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-creational-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>设计模式学习-单件（Singleton）
    </h2>
  </header>
  <div class="entry-content">
    <p>意图： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
结构图： 代码示例： public class Singleton { private static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; } public void test() { System.out.println(&#34;Singleton test&#34;); } public static void main(String[] args) { Singleton s = Singleton.getInstance(); s.test(); } } 效果： 因为Singleton类封装它的唯一实例，所以它可以严格的控制。
注意： Singleton不是说只能唯一，也可以控制其实例的数量，对多个实例的创建和控制。
Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时刻配置应用。
实现： 保证一个唯一的实例是该模式的重点，不同语言对此有不同的方法。面对语言特性，还需要注意并发同步等问题。
相关模式： Abstract Factory、Builder、Prototype都可以用Singleton实现。</p>
  </div>
  <footer class="entry-footer"><span title='2013-07-31 09:39:00 +0800 CST'>July 31, 2013</span></footer>
  <a class="entry-link" aria-label="post link to 设计模式学习-单件（Singleton）" href="https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-singleton/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>设计模式学习-原型（Prototype）
    </h2>
  </header>
  <div class="entry-content">
    <p>很少见到，我都没遇到过，或是遇到过也没注意。
意图： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
结构： Prototype
——声明一个克隆自身的接口 ConcretePrototype
——实现一个克隆自身的操作 示例代码: public abstract class Prototype implements Cloneable { public Prototype clone() { try { return (Prototype) super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return null; } public abstract String getThing(); } public class ConcretePrototype extends Prototype { @Override public String getThing() { return &#34;ConcretePrototype&#34;; } } public class Client { public static void main(String[] args) { ConcretePrototype cp = new ConcretePrototype(); ConcretePrototype newCp = (ConcretePrototype) cp....</p>
  </div>
  <footer class="entry-footer"><span title='2013-07-30 17:23:00 +0800 CST'>July 30, 2013</span></footer>
  <a class="entry-link" aria-label="post link to 设计模式学习-原型（Prototype）" href="https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-prototype/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://blog.qiwei.dev/posts/page/2/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://blog.qiwei.dev/posts/page/4/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://blog.qiwei.dev/">我的博客</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
