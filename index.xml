<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>我的博客</title>
    <link>https://blog.qiwei.dev/</link>
    <description>Recent content on 我的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 03 Aug 2023 20:23:05 +0800</lastBuildDate><atom:link href="https://blog.qiwei.dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>多机房自动化部署</title>
      <link>https://blog.qiwei.dev/posts/other/automatic-deployment-of-multiple-computer-rooms/</link>
      <pubDate>Thu, 03 Aug 2023 20:23:05 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/other/automatic-deployment-of-multiple-computer-rooms/</guid>
      <description>之前入职了一家小公司，接了一个任务，实现多机房的自动化部署。
大致的情况如下：
公司产品主要面向政府，产品大部分都部署政府的机房中； 有一套jinkens，但是只能实现公司自己机房的部署； 现在外部机房的部署要么靠开发登上去后手动传包部署，要么由运维代为操作； 政府机房连接困难，VPN+二次验证+堡垒机+SSH，同时也不允许开放公网入口； 并没有采用任何云原生技术或容器技术。 从上述情况看，就VPN+二次验证这一点，基本毙掉了大部分互联网公司的方案。网上能看到的方案，无论大厂还是小厂的，单机房还是多机房多活，基本都是自己机房，可控权限高。采用这些方案的话，就要设法实现VPN+二次验证的自动化。面对不同政府机房不同VPN，这条路并不好走。
我没有DevOps开发经验，对于运维自动化也了解很少，只能找了些工具作为参考。最后决定模仿SaltStack，做一个C/S结构的发布平台。在服务端，主要是流程控制，从发布计划到单次发布作业，流程标准化、可追溯、可视化。客户端采用轮询方式，主动去服务端获取发布作业，然后执行相关的部署工作。
主动的轮询，客户端主动连接服务器，而不是服务器去连接客户端，这样政府机房服务器并不需要开放端口给外部使用。客户端通过公网访问服务端，也避开了VPN这一层。和SaltStack不同的是，我们的客户端在一个机房之部署一个，有一个客户端负载整个机房的部署任务。也是因为政府机房每台服务器都开放公网访问。客户端可以通过SSH连接每一台同机房服务器，类似于Ansible。C/S结构还有一个好处是以根据不同环境来做各种定制客户端，避免了服务端去适配。
基本框架订好了，剩下的就是细节问题。应用部署文件需要传输，同时最近的启动参数、配置文件等都需要一并传输过去。为了实现回滚，还需要有一套备份机制。最后还要对应用状态做检查，确定部署是否成功。
安全问题是一个坎，毕竟需要走公网，涉及数据传输，安全性就要求很高。有些对安全要求严格的政府机构可能就不允许这样的方案。
我没等到这个方案落地就离开了这家公司，所以后面无法在具体实现上跟进了。这里只算是记录了初步设想。</description>
    </item>
    
    <item>
      <title>找工作</title>
      <link>https://blog.qiwei.dev/posts/other/job-hunting/</link>
      <pubDate>Fri, 28 Jul 2023 15:17:23 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/other/job-hunting/</guid>
      <description>快35岁那会，对自己工作依然很乐观，毕竟那会互联网行业也蒸蒸日上。加之所在公司也还不错，所以就没有什么想法出去找工作。然后新冠来了，有严重拖延症的我，把换工作这事就一拖再拖。直到所谓的“互联网寒冬”来临，公司开始不断裁员。这才意识到，多年多年的安稳生活就要结束了。
4月份，选择了自愿被裁。一是公司的现状来看，留下也只是继续等待被裁而已；二是在这家公司工作了近8年，现在还能拿一笔丰厚的补偿金；三是相信自己能很快找到一份工作。5月开始就正式成为无业游民，加入了求职大军。原本信心满满，只是一次一次的“拒绝”和“等待”，让我知道了现实的残酷。
虽然最后找到了工作，不过回想这个过程，却让人心里难受。曾经不在乎那个“35岁”，现在成了最大的痛。曾几何时，网上到处都是说程序员过35就面临转折，我自是不信。但是一次一次投递简历，一次一次没有任何回音后，我就清醒了。简历真就卡在了35岁这条上。另外一个问题就是，多面没参加过面试，完全不知道面试会问些什么，需要准备什么。能做的只是网上找各种面试资料。这种无头绪的准备，也让我错失了难得的几次面试机会。
还好我天生乐天派，能一直保持一个乐观的心态，不至于让自己陷入焦虑之中。给自己一句话：“事已至此，努力向前才是最重要的”。懊悔往昔，担忧未来，这些都无法起到任何帮助。
期间联系了很多同行的朋友和过去的同事，沟通感情是次要，主要是看能不能帮内推下。很多公司对内推还是比较重视的。没个优先权么，也至少会正眼看一下简历。果然内推给面试机会的远比瞎投简历的多多了。在此感谢那些帮我推内的朋友们。虽然最后也没一个靠内推拿到offer的，但那都是我自己能力不行，白白错失良机。
说到面试，我对面试的印象还停留在7、8年前。虽然工作后也有作为面试官的机会，不过面试的都是初中级的开发，主要还是问问写八股文，简单聊聊项目经验。自己作为被面试者，那感觉还是天差地别的。这期间的面试次数也不多，而且形式还不尽相同。有一个劲儿问技术问题的，有结合项目经历问技术问题的，也有只深入问项目经历而不问技术的，还有直接给问题让出方案的。林林总总，搞得我都不知道怎么准备。这时候就真体现知识储备量了。不管是技术知识，还有平时看的闲散文章上各种经验总结，能结合自己工作说个事的，都可以拿出来聊一下。所以平常没事多看看技术含量高文章也是有价值的。
新工作并不如意，一则小公司很不稳定，今天看你是人才，明天就嫌弃你薪资贵，把你扫地出门。二是业务都是我以前做过的，毫无新鲜感，工作属于一眼看到头类型，不会有晋身机会，技术也没什么可看的。马上四十的人了，职业生涯基本都进入下半场，虽一事无成但也要考虑下职业规划。之前的业务经验可以为现在找工作带来一定的优势，特别我这种还在这个行业算数一数二的公司工作的，可以拿业务经验去忽悠小公司面试官。但是之前公司都成这样了，也证明这个行业并不好混，现在是看不到任何太光明的前景。是重操旧业还是勇敢地迈向另一个行业，需要深思了。
就到这里，后面估计又是骑驴找马的生活。不知道到退休前还要经历几次求职。</description>
    </item>
    
    <item>
      <title>关于项目提速的思考</title>
      <link>https://blog.qiwei.dev/posts/other/thinking-about-project-speedup/</link>
      <pubDate>Mon, 26 Jun 2023 16:04:36 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/other/thinking-about-project-speedup/</guid>
      <description>这几天在看日剧《重启人生》，第四集中，女主角为了帮助他高中老师，让剧组加速拍摄的桥段。大致剧情是，女主已经是第三世了，为了让自己不投胎变成动物，反复重新开始人生。这一世她做了剧组的工作人员。根据前世记忆，这天她高中老师有难，她需要在21点多赶到地铁站，可是剧组当天的行程要到21点30分结束。除非能提前两个小时结束，不然来不及救老师。于是，她决定提速当天的拍摄进程。当然，在主角光环的作用下，她硬生生让剧组提前了3个小时完成当前拍摄工作。虽然有编剧的扯淡和主角光环，但是，其中很多东西仍然值得多思考下。
我没在剧组工作过，所以对拍戏这是没任何概念。就只能说下在电视中看到的一些拍摄工作的情况。日程是串行的，也就是必须拍摄完一段，才能拍下一段；每段拍摄前需要确保布景、演员、化妆、摄影、灯光等都到位才行；部分演员（特别是重要的演员）都是在指定时间段到达的，并非一直在等待。了解情况后，来看看女主做了些什么事。
1、先让个别的人加快进度 通过个人人际关系，让少部分人先快起来。然后再传递进度变快的消息给其他人，让后面人跟进。剧中，化妆师是她同学，请化妆师加快后，她就回头告诉布景等，说明演员就绪的时间。后续人员看到前面准确就绪时间后，也会相应调整自己的节奏。一环带动另一环，从而让整个进度一点一点提前。
这点的延伸，工作中，很多人都觉得别人会是任务瓶颈，自己并没有必要提前开始或加快完成。因为即使自己完成了，那边也无法跟上。但当大家都这么想的时候，就变成了相互间等待的情况。最后就是都在按工期走。
2、找出可并行事项 一天七八个拍摄任务中，有一个是演员手部特写。这个需要拍摄条件相对容易满足，加之演员本在拍摄完其他内容后，正在休息，可以利用拍摄的特殊性和演员状态，将原本需要等待后面拍摄的工作并行完成。
3、让成员保持良好状态 状态越差，出错概率就越高，出错就要从来，很耽误时间。让成员处在一个良好的状态下，就能让拍摄变得更顺利。剧中，她会选择给剧组成员和演员们，送杯水或者饮料之类的。当然用这种方式就能保证他们状态，就有点扯了。
4、让全员都相信能提前完成任务 很多时候，成员么都不认为能提早完成工作，所以各自都按现有的计划进行，按部就班的工作着。这种状态下，加速几乎是不可能的。所以要让他们都意识到，整个项目已经加速，并且确是能实现这个目标。
5、关注瓶颈，提速瓶颈 瓶颈之所谓瓶颈，就是最能左右整个项目的进度的。如果不把瓶颈搞定，那加速几乎不可能加速。剧中最后一场的演员，因为只有最后一场戏要拍，按预期会在最后一场拍摄前到达，只要够化妆和服装的准备就行了。剧中，女主看完行程后就直接打电话给演员，请他提前来。
6、让关键人物、关键步骤提前就位 虽然关键人或物不一定是瓶颈，但是如果延迟或缺失了，那就会直接阻断整个项目进度。
7、了解队友，相信队友，发挥队友能力 剧中，一个场景中的布景设施坏了。如果换成之前，大家都会选择暂停拍摄，等待修好。特别是现在，他们有很多时间来抵消这个意外所造成的时间浪费。只是在情绪高涨的团队中，团队成员自发排除困难，让拍摄不延误。另一个剧情是，最有以为演员堵在路上，女主果断求助长期跑外景，对东京大大小小街道了如指掌的剧组司机，司机也很愿意给出方案。最后演员准时达到，大家皆大欢喜。
上面是根据剧情总结的内容。总结下来就是：提振信心、聚焦关键、动态规划。
动态规划这个，我之前的项目经历来说，项目的时间规划中，必然有预留应对容错的时间。不管项目经理也好，还是实际干活的成员，都不会估算出很紧凑的排期，多多少少都会预留点应对突发状况的时间。但是最后在没有突发状况时，由于后续排期已定，后面的人也不会提前，前面的人也会因为有充裕时间而放慢节奏。如果可以动态根据实际情况，反复调整排期，也能让项目加速。只是动态的调整必然会打乱其他项目的节奏。
话说《重启人生》这电视剧不错，值得一看。</description>
    </item>
    
    <item>
      <title>DDD的思想的应用</title>
      <link>https://blog.qiwei.dev/posts/arch/ddd-easy-using/</link>
      <pubDate>Wed, 14 Jun 2023 13:04:51 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/arch/ddd-easy-using/</guid>
      <description>我在上一篇说了下我在DDD实践过程中的一些想法。要长期实行DDD的话，领导的支持、人才的培养、领域专家的协助等，都是不可缺少的。很多情况下，我们都无法有这么好的条件。那是不是说，就没什么意义去学习领域驱动设计了呢。其实不然，且听我分析。
我本人兴趣广泛，喜欢东学一点，西学一点，偶尔捣鼓点小东西，自娱自乐下。但是对于一些枯燥的原理东西又不是特别感兴趣，这就导致了很多技术都是懂个皮毛，不深入。所以要往技术架构、技术专家发展就带来了一些困难，于是就想着往业务架构方向发展。只是网络上找了个遍，也很少介绍有关业务架构是能力怎么发展的书籍。后来想了想，业务专精的技术人员，因为受限于从事的行业业务，经验无法在其他行业通用。（这也是想往业务架构发展的技术人员一个要考虑的点。可能后续找工作会成问题。面试的一看是业务架构，偏向业务，要是和公司业务不符，可能直接PASS）。
后来接触了DDD后，了解了其背后的思想，才让我对业务分析这方面有了一定的进步。下面我就说说自己从DDD中学到的。
共识 业务专家不懂技术，技术不动业务，产品就作为了技术和专家中间的桥梁。可产品也有自身的问题，并非每一个产品都能对业务了如指掌，对技术的理解也止步于懂个大概。产品在传递一些信息和概念的时候，多少会参杂自己的理解，有的甚至是曲解。为此，DDD的做法是让专家、产品、技术一起参与项目，一起讨论。其中一个目的是能让项目成员都对业务中的一些定义、名词等达成共识。只有这样才能消除沟通带来的歧义，这也是对业务进一步分析的基础。
一个简单的例子，“订单”这个词不算陌生，但是在一个电商系统中出现“订单”字眼的地方很多，仓储系统、物流系统、交易系统、支付系统等。但是对于不同系统，具体应该是不同的领域，不同的上下文中，“订单”的概念是不同的，有些系统还会出现多种“订单”定义。比如，对于支付系统，就有支付订单和交易订单，而交易订单更多的只是一个与外部关联的值而已，支付订单才是它的业务核心。理清这些内容，建立统一语言，让团队对业务达成共识，这是DDD的思想之一。
从产品经理角度看业务 我很想说从领域专家的角度去看业务，不过这个确实很难做到的。
在了解DDD之前，我从没听过用户旅程、用户故事、事件风暴之类的名词，对产品经理如何分析业务也是一无所知。大部分开发基本都和我一样，对业务的理解都是来自现有代码和产品经理对业务的描述。代码本就是开发写的，而产品经理也不会把自己怎么分析业务的过程对开发说的很详细。这样，开发理解的业务就是很片面，很局限。当问及“某某接口是做什么的”这样的问题时，开发更多的回答就是，这个接口提供了什么样的功能，却无法回答上层的业务是如何的，接口在整个业务场景中的作用是什么。
要理解整个业务，就必须换个方式，换个角度去看业务。如果自己是产品经理，需要给开发讲解业务，能讲解清楚吗？如果自己从零开始分析、设计这款产品，又会怎么做？产品经理那些分析业务的方法自己是否可以学，可以用呢？只能说这样的转换是一个漫长过程，这找不到什么快速的学些方法，我自己还在慢慢摸索。也许有一天，不愿意做开发了，可以做一个懂技术的产品经理。
领域模型 开发不喜欢写文档，写出来的也不怎么靠谱。开发间通用的可能就是各种UML图和架构图这些。只是这些图都不能很好的反应业务，也是导致业务分析结果无法长时间留存和随业务发展而演进。
DDD需要产出领域模型，他是业务的抽象结合技术后的产物。他对开发更友好，虽然丢失了业务细节，但依然能很好反应业务。个人觉得，将领域模型作为整个迭代过程的中心，领域模型前是对业务需求的具体分析，确定领域模型后就是开发在它基础上做技术实现。领域模型也成为后续开发理解业务的一个起点。
从领域模型到代码模块 这个好像没啥好说的，到了实现这部，看的就是个人编码能力了。
DDD的学习，对技术的提升很有限，更多的是在提升对业务的分析能力。这个能力不局限于某一行业或领域，它是通用的。深入学习，以后怼产品、忽悠领导就全靠它了。</description>
    </item>
    
    <item>
      <title>DDD实践杂谈</title>
      <link>https://blog.qiwei.dev/posts/arch/ddd-gossip/</link>
      <pubDate>Tue, 13 Jun 2023 12:54:34 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/arch/ddd-gossip/</guid>
      <description>最近在找工作，深知自己没多少斤两，也只能苦刷八股文。不过在很多招聘的信息中看到了领域驱动设计这个关键词。刚好之前公司实践过这个，也许这个是可以在面试中吹吹的东西。于是乎就努力回想了下之前的经历，希望能整理出点有用的东西。
领域驱动设计，简称DDD，说它是设计思想也好，方法论也好，哲学也好，最后的目的就是让代码能更好反映业务，同时还能控制业务和系统的整体复杂度。其实吗，各种架构、模式、模型什么的，都是在控制复杂度，因为这些复杂就是生产效率的敌人。
以往，如果让我去梳理一个复杂的业务系统。我肯定在了解业务后，提供各种解决的技术方案，然后就是重构。等重构完，确实整个系统的代码会干净、整洁很多。讲得高大上一点，就是耦合度低了，内聚高了，接口设计更合理了，代码可读性也高了。可是当几个迭代版本后，就会发现，似乎有慢慢的回到之前的模样了。这里的两个重点就是，第一、我们的改造方案虽然是基于业务，但是更多还是基于技术角度思考；第二、我们的代码无法一直保持这个良好的状态。我们的工作就在迭代、重构、迭代，再重构的循环中。那如果不重构呢，对于那些还在高速增长的业务系统，忽视技术债务，最终也只会把开发拖入泥潭。
DDD的目标就是解决代码无法随业务模型同步调整的问题。通过维护一套领域模型，让代码随着这套模型一起演进。新的业务功能进入系统时候，需要先融入到这套模型中，才考虑代码的实现。
听上去，除了DDD理念中的统一语言、划分领域，以及一些花哨名词和概念外，并没有什么新花样。其实很多高级开发或架构师，都在做差不多的事情，分析业务，然后根据业务对系统架构和代码做调整。问题是，很多开发留下了最后系统调整的方案，却没有将分析业务的成果留存，或者留存了也没有在后续持续更新，更别说以业务模型作为开发设计的中心。DDD则在需求设计、业务分析、领域模型设计、代码实现等各阶段，提供了一套行之有效的方法。保证领域模型紧随业务变化，代码符合领域模型。
扯了那么多，还是谈谈之前的落地经历吧。说叫落地实践，实际就是摸着石头过河。翻遍了网上的资料，除了大牛那两本后后的书外，很难找到完整的落地方案。很多就介绍了个大概，也没有了啥后续。所以实践就变成了摸索。相对于战略设计，战术设计可能是开发最擅长的，只要在摸清业务，确定领域模型的前提下，战术设计完全可以有开发单方面完成。那战略设计就成为了实践中的重点。团队还是选择了事件风暴这种方式来分析业务。事实也证明“事件风暴”确实很有效果。从事件和用户旅程出发，能很快让开发了解完整的业务。同时挖掘业务流程中，一些不怎么被开发关注的内容。分析完成业务后，后续就是划分领域和上下文，以及模型设计等工作。这个过程也是反反复复的，毕竟对于复杂系统，很难一次性掌握。
DDD的好处，网上随便找一篇文章都能说出一堆来。只是对于落地的难处却说的比较少。我这里就说下过程中遇到的难点。
第一、领域专家难寻
DDD的要求就是和领域专家一起来梳理业务。我们团队刚好在一个比较传统的，或者说行业内业务很成熟的系统中实践DDD，加上公司确实有这方面资源，可以轻松和领域专家一起工作。同时开展DDD实践的另一个团队，那就没这么好运了。对于互联网行业，很多新兴的业务，都是靠着一群富有创新力的人才创造出来的。领域内并没有专家可以找，唯一对业务了解的恐怕就是产品经历了。这种情况下，分析业务就完全靠开发和产品自己对业务的理解了。还有就是领域专家是甲方的，也很难说动甲方参与设计和讨论，特别DDD的模式下，需要长期参与其中。
第二、老板或领导的意愿
很多领导或老板，脑袋一热，就要上DDD，可能并没有了解清楚。当时DDD实践是，就会无形中拖慢整个开发流程。毕竟，对核心业务的每一次调整，都要从需求开始，在业务层面梳理清楚。不像以往的上来就写代码的模式。那些头脑一热的领导，往往会被劝退。在没有上级的支持的情况下，DDD是很难维持的。特别处于长期工期紧张的团队。
第三、人才储备
系统不断的迭代，DDD也不是一锤子买卖。必须有人来负责管理，让团队可以持续进行。团队的其他成员也需要有能力，有意愿支持这种形式。特别是在工期压力大的团队，很可能团队选择逃避这种复杂的设计方式。这种情况下，核心成员的离开，很可能导致后续没有人能接手，从而放弃DDD。
第四、没标准，没最佳实践
网上很多都是说自己实践过，但是也没说持续多久，效果如何，哪些问题，怎么解决这些问题。更谈不上最佳实践了。而DDD本身是方法论、是思想，并没有对过程和产物做标准化定义，那不同团队设计出来的方案各不相同，这也导致了很多东西无法有效推广。
以上都是我个人的一点想法。本人经验有限，可能很多考虑不成熟的地方。</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://blog.qiwei.dev/about/</link>
      <pubDate>Thu, 01 Jun 2023 14:12:43 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/about/</guid>
      <description>关于我</description>
    </item>
    
    <item>
      <title>Zuul网关丢失鉴权信息问题</title>
      <link>https://blog.qiwei.dev/posts/coding/zuul-gateway-lost-auth-info/</link>
      <pubDate>Fri, 28 Jun 2019 15:43:46 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/zuul-gateway-lost-auth-info/</guid>
      <description>公司有个项目使用spring cloud全家桶。由zuul做入口，路由到各个业务系统。其中路由完成登陆鉴权。后来有一个业务系统需要用到这些登陆信息，所以希望路由这端将登陆的信息通过消息头的方式带到业务系统。
想想实现很简单，定义一个feign的拦截器，把登陆信息填到header中。不过中间遇到个小问题。统一的路由中将信息保持到了一个ThreadLocal中，拦截器会从这个ThreadLocal中取出数据。问题就出在这里，取到的数据是空的。其他地方也在使用这个ThreadLocal中的数据，并未发现问题，未读这个feign拦截器却不行。最奇怪的本地测试可以，跑测试环境就不行。
再三排查，也查了不少资料，最后看到有博客上提到差不多的问题，原因是Hystrix的策略导致的。Hystrix使用不同的线程完成工作，也就是说Hystrix的线程与Request不再同一个线程中。这样，基于ThreadLocal的一些功能都无法正常使用。后来再stackoverflow上找到了解决办法，连接。框架的开发者也知道这问题，所以提供了一套完整的解决方案。HystrixRequestContext和HystrixRequestVariableDefault就是用来解决这个跨线程时共享数据问题的。简单的说，放入HystrixRequestVariableDefault中的数据，不管是在Requst线程中，还是在Hystrix的线程中，都可以访问到。不过HystrixRequestVariableDefault必须在每一个请求开始的时候进行初始化，同时在请求结束收回收里面的数据。
方案有了，上代码，先实现一个mvc的拦截器，将ThreadLocal中的数据转到HystrixRequestVariableDefault中：
public class HystrixContext { public static final String LOGIN_INFO_HEADER_KEY = &amp;#34;his-login-info&amp;#34;; public static final String TOKEN_HEADER_KEY = &amp;#34;token&amp;#34;; public static final HystrixRequestVariableDefault&amp;lt;LoginInfo&amp;gt; LOGIN_INFO = new HystrixRequestVariableDefault&amp;lt;&amp;gt;(); } try { if (!HystrixRequestContext.isCurrentThreadInitialized()) { HystrixRequestContext.initializeContext(); } LoginInfo loginInfo = convertLoginInf(request.getHeader(HystrixContext.LOGIN_INFO_HEADER_KEY)); LoginInfoUtil.setInfo(loginInfo); String token = request.getHeader(HystrixContext.TOKEN_HEADER_KEY); LoginInfoUtil.setToken(token); HystrixContext.LOGIN_INFO.set(LoginInfoUtil.getLoginInfo()); } catch (Exception e) { LOG.error(&amp;#34;从头信息中获取数据失败&amp;#34;, e); } 然后给feign加一个拦截器：
try { if (!HystrixRequestContext.isCurrentThreadInitialized()) { HystrixRequestContext.initializeContext(); } LoginInfo loginInfo = HystrixContext.LOGIN_INFO.get(); if (loginInfo !</description>
    </item>
    
    <item>
      <title>Django2 Template 路径配置</title>
      <link>https://blog.qiwei.dev/posts/coding/django2-template-path-config/</link>
      <pubDate>Thu, 22 Mar 2018 15:43:46 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/django2-template-path-config/</guid>
      <description>前端时间在那django些个小网站，其中需要配置下template路径，按以前经验配置了下，
TEMPLATE_DIRS = ( os.path.join(BASE_DIR, &amp;#39;templates&amp;#39;).replace(&amp;#39;\\&amp;#39;, &amp;#39;/&amp;#39;), ) 弄了半天也没成功。最后无奈去看了下官方文档，找到内容有限，不过可以确定的是TEMPLATE_DIRS这个配置项已经没有了。
然后谷歌了下，找到了新的配置方法：
TEMPLATES = [ { &amp;#39;BACKEND&amp;#39;: &amp;#39;django.template.backends.django.DjangoTemplates&amp;#39;, # 这里，这个DIRS就是 &amp;#39;DIRS&amp;#39;: [os.path.join(BASE_DIR, &amp;#39;templates&amp;#39;).replace(&amp;#39;\\&amp;#39;, &amp;#39;/&amp;#39;),], &amp;#39;APP_DIRS&amp;#39;: True, &amp;#39;OPTIONS&amp;#39;: { &amp;#39;context_processors&amp;#39;: [ &amp;#39;django.template.context_processors.debug&amp;#39;, &amp;#39;django.template.context_processors.request&amp;#39;, &amp;#39;django.contrib.auth.context_processors.auth&amp;#39;, &amp;#39;django.contrib.messages.context_processors.messages&amp;#39;, ], }, }, ] 这个方法在django 1.8以上到我现在的2.0.2有效。不保证以后版本依然有效。</description>
    </item>
    
    <item>
      <title>spring cloud feign 拦截器配置</title>
      <link>https://blog.qiwei.dev/posts/coding/spring-cloud-feign-add-interceptor/</link>
      <pubDate>Thu, 25 Jan 2018 20:53:21 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/spring-cloud-feign-add-interceptor/</guid>
      <description>问题 公司大规模推全链路，要求所有应用都接入。手头一个新的项目，采用spring cloud框架。通过 feign 调用rest接口。但是支持提供的支持 HttpClient4 的方式无法对 feign 起作用。
思路 想着 feign 也是采用 HttpClient 的。按理对 HttpClient4 起作用的也应该同样有效。然后去看了下架构组全链路配置代码，原来他们是在初始化 HttpCLient 实例时候，加入了拦截器。通过拦截器，在 header 中加入链路信息。但是这个方式似乎对 feign 没啥作用。那我就自己实现添加拦截器呗。
查了下 feign 添加拦截器，网络上提供的方式都是通过自定义 FeignConfiguration 的方式来实现。方法如下：
新建 FeignConfiguration类
public class FeignConfiguration { @Bean public FeignBasicAuthRequestInterceptor basicAuthRequestInterceptor() { return new FeignBasicAuthRequestInterceptor(); } } 然后在配置客户端调用时候加入配置中
@FeignClient(value = &amp;#34;xxx-service&amp;#34;, path = &amp;#34;/xxx&amp;#34;, configuration = FeignConfiguration.class) 只是这种方法无法做到全局。找了好久，看了文档，都没有办法配置全局。
无奈，去翻源码吧。找到了 FeignAutoConfiguration 类。看到了初始化配置。
protected static class HttpClientFeignConfiguration { @Autowired( required = false ) private HttpClient httpClient; protected HttpClientFeignConfiguration() { } @Bean @ConditionalOnMissingBean({Client.</description>
    </item>
    
    <item>
      <title>javabean字段文字拼接</title>
      <link>https://blog.qiwei.dev/posts/coding/java-bean-field-assemble/</link>
      <pubDate>Sat, 20 Jan 2018 10:58:21 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/java-bean-field-assemble/</guid>
      <description>问题 接了一个需求，从数据库拿出患者的记录，这些记录都是一些吸烟年份、饮酒年份、是否糖尿病等，不是数字就是布尔值，需要通过代码转化为普通人能理解的文字。
思前想后，总不能使用大量 if-else 判断来拼接字符串吧。可以采用模板，但是那样除了必要判空，代码和模板也将分离，不方便维护。而且有些字段存在依赖关系。
解决 刚好之前看了使用注解来替代枚举的方式。想着是否可以在每个需要拼接的字段上打上注解，通过判断注解的方式拼接。注解中也可以放入模板、依赖关系等配置。
@Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface StringAssemble { /** * 模板 */ String template(); /** * 分类 */ String type() default &amp;#34;&amp;#34;; /** * 上级依赖 */ String dependency() default &amp;#34;&amp;#34;; /** * 相互依赖的内容之间的分割符号 */ String dependencySplit() default &amp;#34;,&amp;#34;; } 上面注解中，templete 主要是字段值需要填入的文字模板，type 用于不同的字段组合，dependency 主要是有依赖关系的字段之间的内容组合，最后一个是有依赖关系的字段字段拼接后用于隔离的标点。
实现代码如下：
private static String stringAssemble(Object data, String type, String splitPunctuation) { final Map&amp;lt;String, String&amp;gt; infoMap = new HashMap&amp;lt;&amp;gt;(); final Map&amp;lt;String, String&amp;gt; dependencyMap = new HashMap&amp;lt;&amp;gt;(); try { Field[] fields = data.</description>
    </item>
    
    <item>
      <title>Dubbo统一异常拦截</title>
      <link>https://blog.qiwei.dev/posts/coding/dubbo-exception-filter/</link>
      <pubDate>Mon, 09 Oct 2017 10:02:55 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/dubbo-exception-filter/</guid>
      <description>问题 最近换了岗位，工作内容改成跟着架构师完善公司的技术架构。第一个任务就是做一个统一的异常拦截并返回相关错误码的方案。
公司采用dubbo做分布式框架，按dubbo的推荐，异常已经直接抛给调用方（consumer），只是公司现有的约定是使用错误码。问了几个前辈后才知道，原来dubbo在处理自定义异常的时候有些限制。
public Result invoke(Invoker&amp;lt;?&amp;gt; invoker, Invocation invocation) throws RpcException { try { Result result = invoker.invoke(invocation); if (result.hasException() &amp;amp;&amp;amp; GenericService.class != invoker.getInterface()) { try { Throwable exception = result.getException(); // 如果是checked异常，直接抛出 if (! (exception instanceof RuntimeException) &amp;amp;&amp;amp; (exception instanceof Exception)) { return result; } // 在方法签名上有声明，直接抛出 try { Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes()); Class&amp;lt;?&amp;gt;[] exceptionClassses = method.getExceptionTypes(); for (Class&amp;lt;?&amp;gt; exceptionClass : exceptionClassses) { if (exception.getClass().equals(exceptionClass)) { return result; } } } catch (NoSuchMethodException e) { return result; } // 未在方法签名上定义的异常，在服务器端打印ERROR日志 logger.</description>
    </item>
    
    <item>
      <title>hexo3搭建博客</title>
      <link>https://blog.qiwei.dev/posts/other/blog-with-hexo3/</link>
      <pubDate>Sun, 01 Oct 2017 03:44:13 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/other/blog-with-hexo3/</guid>
      <description>前几天心血来潮，翻出了不知道那年的博客，用户hexo重新搭建了下。把这个是记录下来。
安装 这个不多说，hexo 官方文档有介绍。
配置 基本的一些配置上面，上面也有，还有一些我参考了这篇博客，在此先谢过这位朋友的分享。
遇到的问题及解决 CNAME 文件 因为 Github 需要 CNAME 文件，用于指定域名。不过放在 public 文件夹中的话，只要 clean 一次就没了。网站找了下资料，应该将其放在 source 目录总，这样在生成时候就会一起带到 public 文件夹中。一些博文中需要的图片（images）和favicon.ico等不变的内容也可以一起放在 source 目录下。
README.md文件不渲染 在站点配置文件中添加
skip_render: README.mdstiemap 的生成 需要安装插件
npm install hexo-generator-sitemap --save站点配置文件中添加配置
sitemap:path: sitemap.xml博文永久连接 默认是时间分开。但是这样路径比较长。不方便管理。网上有种方法是urlname。使用urlname来作为链接，避免使用文件名。这样文件名就可以自己定义，方便本地管理。
具体做法是，在站点配置文件中，修改配置如下：
permalink: post/:urlname.html然后在每一篇 post 中都需要加一个urlname，如这篇文章的：
title: 20171001-hexo3搭建博客date: 2017-10-01 03:44:13tags: hexourlname: blog-with-hexo3 缺点是，如果那篇忘记了这个，那生成的 html 文件将会是未知
图片保存 hexo官网有推荐的方法，文档。当时我的觉这个太依赖hexo，不符合markdown的理念。所以，还是选择土办法管理图片，放在 source/images 目录下，post中直接用相对路径应用。亲测可行。
博客的版本控制 hexo 的部署功能，只能建 public 文件夹中的内容推送到 Github 上。而配置文件和博客源文件都无法提交。如果换了电脑或电脑换了，那就什么都要从新开始了。</description>
    </item>
    
    <item>
      <title>SpringMVC没有拦截根路径的问题</title>
      <link>https://blog.qiwei.dev/posts/coding/springmvc-cant-fiter-root-url/</link>
      <pubDate>Tue, 02 Dec 2014 15:22:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/springmvc-cant-fiter-root-url/</guid>
      <description>在使用tomcat和spring mvc开发web项目时候，月到了根路径无法被拦截器拦截的问题。</description>
    </item>
    
    <item>
      <title>Spring4定时任务的注解配置</title>
      <link>https://blog.qiwei.dev/posts/coding/spring-scheduling-annotation-support/</link>
      <pubDate>Mon, 03 Nov 2014 22:57:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/spring-scheduling-annotation-support/</guid>
      <description>Spring4框架下，不使用xml配置文件，而采用注解配置定时任务。</description>
    </item>
    
    <item>
      <title>webpy源码阅读之HelloWorld</title>
      <link>https://blog.qiwei.dev/posts/coding/webpy-source-helloworld/</link>
      <pubDate>Thu, 03 Apr 2014 11:21:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/webpy-source-helloworld/</guid>
      <description>学习webpy框架</description>
    </item>
    
    <item>
      <title>推荐程序员阅读的书籍 -- 编程实践</title>
      <link>https://blog.qiwei.dev/posts/other/developer-read-books-coding/</link>
      <pubDate>Fri, 28 Feb 2014 16:48:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/other/developer-read-books-coding/</guid>
      <description>只是对自己读过的书的一些看法而已。</description>
    </item>
    
    <item>
      <title>Win8.1下安装OpenVPN</title>
      <link>https://blog.qiwei.dev/posts/tool/win8-install-openvpn/</link>
      <pubDate>Tue, 11 Feb 2014 09:26:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/tool/win8-install-openvpn/</guid>
      <description>我在win8.1下安装OpenVPN遇到了两个问题，一是安装时候TAP设备驱动程序安装失败，二是因为系统临时目录带中文而无法正确连接，下面是解决方法。</description>
    </item>
    
    <item>
      <title>PuTTY下如何使用agent forwarding</title>
      <link>https://blog.qiwei.dev/posts/tool/putty-using-agent-forwarding/</link>
      <pubDate>Fri, 17 Jan 2014 16:35:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/tool/putty-using-agent-forwarding/</guid>
      <description>PuTTY下如何使用agent forwarding</description>
    </item>
    
    <item>
      <title>Linux下Django部署环境的搭建</title>
      <link>https://blog.qiwei.dev/posts/coding/python-mode-wsgi-apache-install/</link>
      <pubDate>Wed, 11 Dec 2013 16:19:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/python-mode-wsgi-apache-install/</guid>
      <description>Linux环境下对Python版本的升级和apache、Mod wsgi的安装</description>
    </item>
    
    <item>
      <title>Clone使用方法详解</title>
      <link>https://blog.qiwei.dev/posts/coding/java-clone/</link>
      <pubDate>Thu, 05 Sep 2013 13:29:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/java-clone/</guid>
      <description>在实际编程过程中，我们常常要遇到这种情况：有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能会需要一个和A完全相同新对象B，并且此后对B 任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的。在Java语言中，用简单的赋值语句是不能满足这种需 求的。要满足这种需求虽然有很多途径，但实现clone（）方法是其中最简单，也是最高效的手段。</description>
    </item>
    
    <item>
      <title>Django&#43;apache&#43;mod_wsgi部署</title>
      <link>https://blog.qiwei.dev/posts/coding/django-apache-mod-wsgi-deployment/</link>
      <pubDate>Mon, 02 Sep 2013 10:20:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/django-apache-mod-wsgi-deployment/</guid>
      <description>Django&#43;apache&#43;mod_wsgi部署</description>
    </item>
    
    <item>
      <title>Django基础入门</title>
      <link>https://blog.qiwei.dev/posts/coding/django-study-start/</link>
      <pubDate>Thu, 29 Aug 2013 17:01:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/django-study-start/</guid>
      <description>Django基础</description>
    </item>
    
    <item>
      <title>Java静态代码块（static{}）</title>
      <link>https://blog.qiwei.dev/posts/coding/java-static-code-block/</link>
      <pubDate>Wed, 21 Aug 2013 10:43:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/java-static-code-block/</guid>
      <description>与一般代码块的异同：相同点：都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，一般在代码块中对一些static变量进行赋值。不同点：静态代码块在非静态代码块之前执行。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。非静态代码块可在普通方法中定义；而静态代码块不行。</description>
    </item>
    
    <item>
      <title>Java源码解读——ArrayList</title>
      <link>https://blog.qiwei.dev/posts/coding/java-source-arraylist/</link>
      <pubDate>Wed, 14 Aug 2013 15:11:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/java-source-arraylist/</guid>
      <description>ArrayList是一个实现可变长数组，继承AbstractList类，实现所有的List接口，还实现了RandomAccess、Cloneable、Serializable接口。ArrayList不进行同步，除此之外基本和Vector等同。</description>
    </item>
    
    <item>
      <title>编写可读代码的艺术-代码应当易于理解</title>
      <link>https://blog.qiwei.dev/posts/coding/the-art-of-readable-code/</link>
      <pubDate>Fri, 09 Aug 2013 17:12:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/the-art-of-readable-code/</guid>
      <description>在日常的工作中，去理解他人代码或是他人来阅读你的代码的情景时常有。甚至自己也会忘记自己所写代码的含义，一周或一个月后再去看自己的代码，都觉得那么陌生。项目的维护时间远多余开发，当后期需要再次开发或修改BUG的时候，那些好的、易于理解的代码将大大节省时间。所以编写可读代码不经方便他人，还能提高自身的工作效率。</description>
    </item>
    
    <item>
      <title>霸王别姬-人生一场戏</title>
      <link>https://blog.qiwei.dev/posts/other/farewell-my-concubine/</link>
      <pubDate>Fri, 09 Aug 2013 12:39:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/other/farewell-my-concubine/</guid>
      <description>我喜欢戏班子师傅教导徒弟那几话：第一句，人得自各儿成全自各儿。第二句，自古人生一世，需有一技之长，我辈既务斯业，便当专心用功，以后名扬四海，根据全在年轻。是啊，我的一技之长是什么——编程。只能专心用功，以后希望名扬四海。</description>
    </item>
    
    <item>
      <title>设计模式学习-组合模式（Composite）</title>
      <link>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-composite/</link>
      <pubDate>Thu, 08 Aug 2013 15:27:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-composite/</guid>
      <description>组合模式将对象组合成树形结构以表示“部分 -整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。</description>
    </item>
    
    <item>
      <title>原型工厂模式</title>
      <link>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-prototype-factory/</link>
      <pubDate>Wed, 31 Jul 2013 13:58:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-prototype-factory/</guid>
      <description>顾名思义就是原型模式和工厂模式的结合。在GOF的书里面，抽象工厂那节中对这个有描述，不过内容很少，所以看的时候也没注意到。</description>
    </item>
    
    <item>
      <title>设计模式学习-桥接模式（Bridge）</title>
      <link>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-bridge/</link>
      <pubDate>Wed, 31 Jul 2013 13:44:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-bridge/</guid>
      <description>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。</description>
    </item>
    
    <item>
      <title>设计模式学习-适配器（Adapter）</title>
      <link>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-adapter/</link>
      <pubDate>Wed, 31 Jul 2013 12:26:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-adapter/</guid>
      <description>将一个类的接口转换成客户希望的另外一个接口。 Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</description>
    </item>
    
    <item>
      <title>设计模式学习-创建型模式</title>
      <link>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-creational-pattern/</link>
      <pubDate>Wed, 31 Jul 2013 09:59:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-creational-pattern/</guid>
      <description>用于创建对象的模式。包括单件模式（Singleton）、抽象工厂模式（Abstract Factory）、生成器模式（Builder）、工厂方法模式（Factory Method）、原型模式（Prototype）。</description>
    </item>
    
    <item>
      <title>设计模式学习-单件（Singleton）</title>
      <link>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-singleton/</link>
      <pubDate>Wed, 31 Jul 2013 09:39:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-singleton/</guid>
      <description>单件可以保证一个类仅有一个实例，并提供一个访问它的全局访问点。</description>
    </item>
    
    <item>
      <title>设计模式学习-原型（Prototype）</title>
      <link>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-prototype/</link>
      <pubDate>Tue, 30 Jul 2013 17:23:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-prototype/</guid>
      <description>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</description>
    </item>
    
    <item>
      <title>设计模式学习-工厂方法（Factory Method）</title>
      <link>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-factory-method/</link>
      <pubDate>Tue, 30 Jul 2013 16:21:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-factory-method/</guid>
      <description>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使一个类的实例化延迟到其子类。</description>
    </item>
    
    <item>
      <title>设计模式学习-生成器（Builder）</title>
      <link>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-builder/</link>
      <pubDate>Tue, 30 Jul 2013 15:56:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-builder/</guid>
      <description>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，java的StringBuilder就是一个Builder模式的例子。</description>
    </item>
    
    <item>
      <title>设计模式学习-抽象工厂（Abstract Factory）</title>
      <link>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-abstract-factory/</link>
      <pubDate>Mon, 29 Jul 2013 16:56:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/design-patterns/design-patterns-abstract-factory/</guid>
      <description>抽象工厂，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</description>
    </item>
    
    <item>
      <title>《重构》学习笔记-构筑测试系统与大型重构</title>
      <link>https://blog.qiwei.dev/posts/coding/refactioring/refactioring-read-3/</link>
      <pubDate>Mon, 29 Jul 2013 13:28:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/refactioring/refactioring-read-3/</guid>
      <description>学习《重构 改善既有代码的设计》，了解测试对重构的意义和作用，以及大型的重构。</description>
    </item>
    
    <item>
      <title>《重构》学习笔记-代码的坏味道</title>
      <link>https://blog.qiwei.dev/posts/coding/refactioring/refactioring-read-2/</link>
      <pubDate>Mon, 29 Jul 2013 13:09:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/refactioring/refactioring-read-2/</guid>
      <description>学习《重构 改善既有代码的设计》，认识代码的坏味道。</description>
    </item>
    
    <item>
      <title>《重构》学习笔记-重构原则</title>
      <link>https://blog.qiwei.dev/posts/coding/refactioring/refactioring-read-1/</link>
      <pubDate>Sun, 28 Jul 2013 22:01:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/refactioring/refactioring-read-1/</guid>
      <description>学习《重构 改善既有代码的设计》的笔记，了解如何重构以及重构的时机。</description>
    </item>
    
    <item>
      <title>保护眼睛，设置eclipse文本编辑背景色为自然绿</title>
      <link>https://blog.qiwei.dev/posts/tool/eclipse-green-color-theme/</link>
      <pubDate>Fri, 26 Jul 2013 12:02:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/tool/eclipse-green-color-theme/</guid>
      <description>保护眼睛，设置eclipse文本编辑背景色为自然绿，“色调”的参数设置为85，把“饱和度”参数设置为123，把“亮度”参.数设置为205 红199 绿237 蓝204</description>
    </item>
    
    <item>
      <title>我的第一篇博文</title>
      <link>https://blog.qiwei.dev/posts/other/my-first-blog/</link>
      <pubDate>Thu, 25 Jul 2013 21:51:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/other/my-first-blog/</guid>
      <description>终于有了自己的域名，在Github上开了自己的博客。之前也坚持写过博客，可惜赶上妻子怀孕和儿子出生，忙里忙外了一年后，博客就再没更新。这次申请了自己的域名，就是希望给自己点动力，再开始自己的博客。</description>
    </item>
    
    <item>
      <title>Mybatis返回特殊Map</title>
      <link>https://blog.qiwei.dev/posts/coding/mybatis-special-map/</link>
      <pubDate>Sat, 04 Aug 2012 23:00:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/mybatis-special-map/</guid>
      <description>想返回个特殊实体，一个Map，key是一个表的一个字段的值，value是另一个表的所有记录。参考了下网上的“攻略”，不过和攻略里面讲的有点不同，那里面key的值value的实体实在同一个表内，如果不同表，会报缺少set方法的异常。解决方法很简单，就是在实体里面加个字段对应的属性。但是并不愿意为了一个查询语句就要去改变实体。
无聊看了下session的select，提供了通过 ResultHandler 来处理返回的结果集。所以尝试着解决这个问题。
mapper.xml里面的配置如下：
&amp;lt;resultMap type=&amp;#34;HashMap&amp;#34; id=&amp;#34;testMap&amp;#34;&amp;gt; &amp;lt;result column=&amp;#34;UA_INFO&amp;#34; property=&amp;#34;key&amp;#34; /&amp;gt; &amp;lt;association property=&amp;#34;value&amp;#34; resultMap=&amp;#34;com.xxx.xxx.BaseResultMap&amp;#34;&amp;gt; &amp;lt;/association&amp;gt; &amp;lt;/resultMap&amp;gt; &amp;lt;select id=&amp;#34;getUaMapByTimestamp&amp;#34; parameterType=&amp;#34;Map&amp;#34; resultMap=&amp;#34;testMap&amp;#34;&amp;gt; SQL语句 &amp;lt;/select&amp;gt; com.xxx.xxx.BaseResultMap是另一个实体的mapper的resultMap。这个查询，返回的每一条记录都是 {key=..., value=...}
这个结果集并不符合要求。不过通过ResultHandler来处理每一条记录就可以达到要求了。
看下Mybatis源码里面有关继承 ResultHandler 的 DefaultMapResultHandler类。
public class DefaultMapResultHandler&amp;lt;K, V&amp;gt; implements ResultHandler { private final Map&amp;lt;K, V&amp;gt; mappedResults; private final String mapKey; @SuppressWarnings(&amp;#34;unchecked&amp;#34;) public DefaultMapResultHandler(String mapKey, ObjectFactory objectFactory) { this.mappedResults = objectFactory.create(Map.class); this.mapKey = mapKey; } public void handleResult(ResultContext context) { // TODO is that assignment always true?</description>
    </item>
    
    <item>
      <title>Java可变参数方法及它的重载</title>
      <link>https://blog.qiwei.dev/posts/coding/java-varargs-method-overload/</link>
      <pubDate>Sat, 28 Apr 2012 12:00:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/java-varargs-method-overload/</guid>
      <description>Java可变参数方法及它的重载</description>
    </item>
    
    <item>
      <title>Hibernate获取返回值报XXX connot be cast to [Ljava.lang.Object</title>
      <link>https://blog.qiwei.dev/posts/coding/hibernate-cannot-cast/</link>
      <pubDate>Thu, 03 Nov 2011 21:41:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/hibernate-cannot-cast/</guid>
      <description>今天在测试时候发现在获取Hibernate返回数据时候报 java.math.BigDecimal cannot be cast to \[Ljava.lang.Object 异常，但是查看了代码，很简单也很平常，createNativeQuery执行，getResultList获取结果集，每行都用Object[]类型。调试时候发现返回结果集为[2]，也就是就一行且一个。也就是说，每行的类型不再是 Object[]。
按以往， getResultList 的返回是一个 List(Object\[\])，当如果返回只有一个，比如1或2是，类型就变成了该数据库字段所对应的类型，在我这里就是BigDecimal。
真是不明白，多个就是Object[]，一个就变成不是数组了。 Hibernate莫名其妙啊。发下牢骚。。。</description>
    </item>
    
    <item>
      <title>itext中文本的绝对位置放置</title>
      <link>https://blog.qiwei.dev/posts/coding/itext-absolute-position/</link>
      <pubDate>Thu, 12 May 2011 12:02:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/itext-absolute-position/</guid>
      <description>itext中文本的绝对位置放置</description>
    </item>
    
    <item>
      <title>用apache的ant解压zip文件（中文文件或文件夹解决方法）</title>
      <link>https://blog.qiwei.dev/posts/coding/apache-ant-unzip-chinese/</link>
      <pubDate>Fri, 04 Mar 2011 12:01:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/apache-ant-unzip-chinese/</guid>
      <description>用apache的ant解压zip文件（中文文件或文件夹解决方法）</description>
    </item>
    
    <item>
      <title>ClientAbortException: java.net.SocketException:”异常的问题</title>
      <link>https://blog.qiwei.dev/posts/coding/web-pic-stream/</link>
      <pubDate>Wed, 08 Dec 2010 22:35:00 +0800</pubDate>
      
      <guid>https://blog.qiwei.dev/posts/coding/web-pic-stream/</guid>
      <description>前几天，在做图片以stream形式输出到页面上展现的时候，后台一直报异常，且页面上图片无法正常现实。异常内容为：
ClientAbortException: java.net.SocketException: Software caused connection abort: socket write error at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:358) at org.apache.tomcat.util.buf.ByteChunk.flushBuffer(ByteChunk.java:434) at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:309) at org.apache.catalina.connector.OutputBuffer.flush(OutputBuffer.java:288) at org.apache.catalina.connector.CoyoteOutputStream.flush(CoyoteOutputStream.java:98) at javax.imageio.stream.FileCacheImageOutputStream.close(FileCacheImageOutputStream.java:213) ...... 在网上找了好久，发现是个普遍问题，但原因各异，有人总结为：
1：服务器的并发连接数超过了其承载量，服务器会将其中一些连接Down掉；
2：客户关掉了浏览器，而服务器还在给客户端发送数据；
3：浏览器端按了Stop；
4：服务器给客户端响应结果给防火墙拦截了。
这些原因太过笼统，细查错误很难。
偶然在一个英文网页上看到了条有关这个异常的，本人英语水平差，只能说个大意：
这个已知异常出现在IE浏览器显示tif格式的图片的时候。
亲自试验了下，的确在chrome和火狐上显示时，后台不会报次错误，不过图片显示有点异样。因为图片是存于数据库的BLOB类型的字段中，所以一直没注意图片的格式，后来才发现，原来图片是gif格式，而我使用ImageIO.write(img, &amp;ldquo;jpeg&amp;rdquo;, response.getOutputStream());输出成jpg格式的图片，以致导致IE浏览器对图片解析有问题。在此将jpeg改成gif后不再出现异常。
忙乎了一天多，结果问题出在这里。
其问题导致的原因可能是：IE浏览器在解析错误图片格式或不支持的图片格式时，可能向服务器发送了多次请求或是直接关闭了连接，从而导致了tomcat报次异常。</description>
    </item>
    
  </channel>
</rss>
